<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CapsLockX – Browser Test</title>
<style>
:root {
  --bg:      #1e1e2e;
  --surface: #313244;
  --border:  #45475a;
  --text:    #cdd6f4;
  --muted:   #6c7086;
  --accent:  #cba6f7;
  --green:   #a6e3a1;
  --yellow:  #f9e2af;
  --red:     #f38ba8;
  --blue:    #89b4fa;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  min-height: 100vh;
}

/* ── Virtual cursor overlay ──────────────────────────────────────────── */
#clx-cursor {
  position: fixed;
  top: 0; left: 0;
  pointer-events: none;
  z-index: 9999;
  display: none;
  will-change: transform;
  /* The SVG hotspot is top-left, no offset needed */
}

/* ── Header ──────────────────────────────────────────────────────────── */
header {
  position: sticky; top: 0; z-index: 100;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0.6rem 1.5rem;
  display: flex; align-items: center; gap: 1rem;
}

header h1 { font-size: 1rem; font-weight: 600; }

#status {
  margin-left: auto;
  padding: 0.25rem 0.75rem;
  border-radius: 2rem;
  font-size: 0.8rem; font-weight: 700; letter-spacing: 0.06em;
  transition: background 0.12s, color 0.12s;
}
#status.off    { background: #313244; color: var(--muted); }
#status.fn     { background: #f9e2af1a; color: var(--yellow); border: 1px solid #f9e2af33; }
#status.locked { background: #cba6f71a; color: var(--accent); border: 1px solid #cba6f733; }

#wasm-badge {
  font-size: 0.75rem; padding: 0.2rem 0.6rem; border-radius: 2rem;
  background: #f38ba81a; color: var(--red); border: 1px solid #f38ba833;
  transition: all 0.2s;
}
#wasm-badge.ok { background: #a6e3a11a; color: var(--green); border-color: #a6e3a133; }

/* ── Layout ──────────────────────────────────────────────────────────── */
main {
  display: grid;
  grid-template-columns: 300px 1fr;
  grid-template-rows: auto auto auto auto;
  gap: 1rem;
  padding: 1rem 1.5rem;
  max-width: 1100px;
}

section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 0.6rem;
  padding: 1rem;
}

h2 {
  font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.1em; color: var(--accent); margin-bottom: 0.75rem;
}

/* ── Hotkey table ─────────────────────────────────────────────────────── */
#ref { grid-column: 1; grid-row: 1 / 3; }

table { width: 100%; border-collapse: collapse; font-size: 0.82rem; }
tr + tr td { border-top: 1px solid #ffffff08; }
td { padding: 0.28rem 0; }
td:first-child { color: var(--muted); white-space: nowrap; padding-right: 0.75rem; }

kbd {
  display: inline-block;
  background: var(--bg); border: 1px solid var(--border);
  border-radius: 0.25rem; padding: 0 0.35rem;
  font-family: 'Cascadia Code', 'Consolas', monospace;
  font-size: 0.78rem; line-height: 1.6;
}

.section-label {
  font-size: 0.72rem; color: var(--blue); text-transform: uppercase;
  letter-spacing: 0.06em; padding-top: 0.5rem; padding-bottom: 0.1rem;
  border-top: 1px solid var(--border); margin-top: 0.4rem;
}

/* ── Editor test ─────────────────────────────────────────────────────── */
#editor-section { grid-column: 2; grid-row: 1; }

textarea {
  width: 100%; height: 170px;
  background: var(--bg); color: var(--text);
  border: 1px solid var(--border); border-radius: 0.4rem;
  padding: 0.6rem 0.75rem;
  font-family: 'Cascadia Code', 'Consolas', monospace;
  font-size: 0.88rem; line-height: 1.7; resize: vertical; outline: none;
  tab-size: 2;
}
textarea:focus { border-color: var(--accent); }

/* ── Key log ─────────────────────────────────────────────────────────── */
#log-section { grid-column: 2; grid-row: 2; }

#log-box {
  height: 150px; overflow-y: auto;
  background: var(--bg); border: 1px solid var(--border); border-radius: 0.4rem;
  padding: 0.3rem;
  font-family: 'Cascadia Code', 'Consolas', monospace; font-size: 0.78rem;
}

.le {
  display: grid; grid-template-columns: 5ch 2.5ch 1fr 1fr;
  gap: 0.5rem; padding: 0.15rem 0.4rem; border-radius: 0.25rem;
}
.le:nth-child(odd) { background: #ffffff05; }
.le-t  { color: var(--muted); }
.le-dn { color: var(--green); }
.le-up { color: var(--red); }
.le-code { color: var(--accent); }
.le-key  { color: var(--text); }

/* ── Scroll test ─────────────────────────────────────────────────────── */
#scroll-section { grid-column: 1; grid-row: 3; }
#scroll-box {
  height: 130px; overflow-y: scroll;
  background: var(--bg); border: 1px solid var(--border); border-radius: 0.4rem;
  padding: 0.5rem 0.75rem; font-size: 0.82rem;
}
#scroll-box div { padding: 1px 0; border-bottom: 1px solid #ffffff06; }

/* ── How it works ────────────────────────────────────────────────────── */
#hints { grid-column: 2; grid-row: 3; }
#hints p { font-size: 0.82rem; color: var(--muted); margin-bottom: 0.4rem; }
#hints p span { color: var(--text); }
#hints code {
  background: var(--bg); border: 1px solid var(--border);
  border-radius: 0.3rem; padding: 0.15rem 0.5rem;
  font-family: 'Cascadia Code', 'Consolas', monospace; font-size: 0.78rem;
  color: var(--yellow); display: inline-block; margin-top: 0.3rem;
}

/* ── Focus / WASD test ───────────────────────────────────────────────── */
#focus-section { grid-column: 1 / -1; grid-row: 4; }

.focus-inputs {
  display: flex; flex-wrap: wrap; gap: 0.6rem; margin-top: 0.5rem;
}
.focus-inputs input[type="text"] {
  background: var(--bg); color: var(--text);
  border: 1px solid var(--border); border-radius: 0.4rem;
  padding: 0.35rem 0.65rem; font-size: 0.85rem; outline: none;
  width: 160px;
}
.focus-inputs input[type="text"]:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px #cba6f733;
}
.focus-inputs label {
  display: flex; flex-direction: column; gap: 0.2rem;
  font-size: 0.72rem; color: var(--muted); text-transform: uppercase;
  letter-spacing: 0.06em;
}
.wasd-hint {
  margin-top: 0.6rem;
  font-size: 0.82rem; color: var(--muted);
}
.wasd-hint span { color: var(--text); }

/* ── Error banner ────────────────────────────────────────────────────── */
#err {
  grid-column: 1 / -1; display: none;
  background: #f38ba81a; border: 1px solid #f38ba844;
  border-radius: 0.5rem; padding: 0.75rem 1rem;
  color: var(--red); font-size: 0.88rem; line-height: 1.6;
}
#err code { color: var(--yellow); background: var(--bg); padding: 0.1rem 0.4rem; border-radius: 0.25rem; }

tip { font-size: 0.78rem; color: var(--muted); display: block; margin-top: 0.4rem; }
</style>
</head>
<body>

<!-- Virtual cursor overlay (shown when CLX active + WASD used) -->
<div id="clx-cursor" aria-hidden="true">
  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="20" viewBox="0 0 18 20" fill="none">
    <path d="M1 1L1 16L5.5 11.5L8.5 19L11.5 17.5L8.5 10.5L14 10.5Z"
          fill="white" stroke="#111" stroke-width="1.5" stroke-linejoin="round"/>
  </svg>
</div>

<header>
  <span style="font-size:1.1rem">⌨</span>
  <h1>CapsLockX · Browser Test</h1>
  <div id="status" class="off">CLX OFF</div>
  <div id="wasm-badge">WASM loading…</div>
</header>

<main>

  <!-- ── Error banner ──────────────────────────────────────────────── -->
  <div id="err">
    Failed to load the WASM module.  Build it first, then serve via HTTP:<br>
    <code>wasm-pack build --target web rs/adapters/browser</code><br>
    <code>npx serve rs/adapters/browser  # or: python -m http.server -d rs/adapters/browser</code><br>
    Then open <code>http://localhost:3000/www/</code> (or the port your server uses).
  </div>

  <!-- ── Hotkey reference ──────────────────────────────────────────── -->
  <section id="ref">
    <h2>Hotkey Reference</h2>
    <table>
      <tr class="section-label"><td colspan="2">CLX‑Edit (cursor)</td></tr>
      <tr><td><kbd>H</kbd><kbd>J</kbd><kbd>K</kbd><kbd>L</kbd></td><td>← ↓ ↑ → (accel)</td></tr>
      <tr><td><kbd>Y</kbd> / <kbd>O</kbd></td><td>Home / End</td></tr>
      <tr><td><kbd>U</kbd> / <kbd>I</kbd></td><td>Page Up / Down</td></tr>
      <tr><td><kbd>G</kbd></td><td>Enter</td></tr>
      <tr><td><kbd>T</kbd></td><td>Delete</td></tr>
      <tr><td><kbd>N</kbd> / <kbd>P</kbd></td><td>Focus next / prev</td></tr>

      <tr class="section-label"><td colspan="2">CLX‑Mouse (virtual cursor)</td></tr>
      <tr><td><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></td><td>Move virtual cursor</td></tr>
      <tr><td><kbd>R</kbd> / <kbd>F</kbd></td><td>Scroll up / down at cursor</td></tr>
      <tr><td><kbd>E</kbd> / <kbd>Q</kbd></td><td>Left / Right click (visual only)</td></tr>

      <tr class="section-label"><td colspan="2">CLX‑Media (F5–F11)</td></tr>
      <tr><td><kbd>F5</kbd></td><td>Play / Pause</td></tr>
      <tr><td><kbd>F6</kbd> / <kbd>F7</kbd></td><td>Prev / Next track</td></tr>
      <tr><td><kbd>F8</kbd></td><td>Stop</td></tr>
      <tr><td><kbd>F9</kbd> / <kbd>F10</kbd></td><td>Volume + / −</td></tr>
      <tr><td><kbd>F11</kbd></td><td>Mute</td></tr>

      <tr class="section-label"><td colspan="2">Trigger keys</td></tr>
      <tr><td><kbd>CapsLock</kbd></td><td>Hold to activate</td></tr>
      <tr><td><kbd>Space</kbd></td><td>Hold to activate</td></tr>
      <tr>
        <td><kbd>CapsLock</kbd>+<kbd>Space</kbd></td>
        <td>Lock CLX (tap either to unlock)</td>
      </tr>
    </table>
    <tip>The virtual cursor appears when you first use WASD. Moving the real mouse snaps it back.</tip>
  </section>

  <!-- ── Editor test ───────────────────────────────────────────────── -->
  <section id="editor-section">
    <h2>Cursor / Edit Test · hold <kbd>CapsLock</kbd> then use HJKL</h2>
    <textarea id="editor" autofocus spellcheck="false">The quick brown fox jumps over the lazy dog.
Pack my box with five dozen liquor jugs.
How vexingly quick daft zebras jump!

Hold CapsLock and:
  H / L  →  move cursor left / right (hold for acceleration)
  K / J  →  move cursor up / down
  Y / O  →  jump to line start / end
  U / I  →  page up / page down
  G      →  insert newline
  T      →  delete character ahead of cursor
  N / P  →  focus next / previous element</textarea>
    <tip>The key log below shows only events CLX <em>passed through</em> — CLX hotkeys won't appear there.</tip>
  </section>

  <!-- ── Key log ───────────────────────────────────────────────────── -->
  <section id="log-section">
    <h2>
      Key Log
      <span style="font-size:0.72rem;color:var(--muted);font-weight:400;text-transform:none;letter-spacing:0">
        — events that reached the page (CLX-intercepted keys are absent)
      </span>
      <button id="clear-log" style="float:right;font-size:0.72rem;background:none;border:1px solid var(--border);
        color:var(--muted);border-radius:0.3rem;padding:0 0.5rem;cursor:pointer">clear</button>
    </h2>
    <div id="log-box"></div>
  </section>

  <!-- ── Scroll test ───────────────────────────────────────────────── -->
  <section id="scroll-section">
    <h2>Scroll box · CLX + <kbd>R</kbd> / <kbd>F</kbd></h2>
    <div id="scroll-box"></div>
    <tip>Move the virtual cursor over this box (WASD), then press CLX+R/F to scroll it.
    R/F always scroll the scrollable element under the virtual cursor.</tip>
  </section>

  <!-- ── How it works ──────────────────────────────────────────────── -->
  <section id="hints">
    <h2>How it works</h2>
    <p>
      <span>Hook:</span> capture-phase <code>keydown</code>/<code>keyup</code> listeners on <code>window</code>.
      Intercepted events get <code>preventDefault()</code> + <code>stopPropagation()</code>.
    </p>
    <p>
      <span>Cursor (HJKL):</span> synthetic <code>ArrowLeft/Right/Up/Down</code> dispatched on the
      focused element. <code>isTrusted=false</code> but browsers still move the text cursor.
    </p>
    <p>
      <span>Virtual mouse (WASD):</span> WASM dispatches <code>clx:mouse_move [dx,dy]</code>;
      JS renders a cursor overlay and moves it. Real <code>mousemove</code> snaps it back.
    </p>
    <p>
      <span>Scroll (R/F):</span> WASM dispatches <code>clx:scroll_v/h</code>;
      JS walks up from <code>elementFromPoint(vx, vy)</code> to find the nearest
      scrollable ancestor and calls <code>scrollBy</code> on it.
    </p>
    <p>
      <span>Focus (N/P):</span> WASM dispatches <code>clx:focus ±1</code>;
      JS cycles through <code>querySelectorAll</code> of all tabbable elements.
    </p>
  </section>

  <!-- ── Focus / WASD test ─────────────────────────────────────────── -->
  <section id="focus-section">
    <h2>Focus test · CLX + <kbd>N</kbd> (next) / <kbd>P</kbd> (prev)</h2>
    <div class="focus-inputs">
      <label>Field 1<input id="focus-field-1" type="text" placeholder="tab here…"></label>
      <label>Field 2<input id="focus-field-2" type="text" placeholder="tab here…"></label>
      <label>Field 3<input id="focus-field-3" type="text" placeholder="tab here…"></label>
    </div>
    <p class="wasd-hint">
      <span>Virtual cursor:</span> hold CLX + WASD to move the crosshair cursor.
      Move it over the scroll box above, then CLX+F to scroll that box, not the page.
      Real mouse movement instantly snaps the virtual cursor back.
    </p>
  </section>

</main>

<script type="module">
// ── Virtual cursor ────────────────────────────────────────────────────────────
// vx/vy track the virtual cursor position; they snap to the real mouse on
// mousemove and are offset by WASD delta from WASM.

let vx = window.innerWidth  / 2;
let vy = window.innerHeight / 2;
let cursorVisible = false;

const cursorEl = document.getElementById('clx-cursor');

function setCursorPos(x, y) {
  vx = Math.max(0, Math.min(window.innerWidth  - 1, x));
  vy = Math.max(0, Math.min(window.innerHeight - 1, y));
  cursorEl.style.transform = `translate(${vx}px,${vy}px)`;
}

// Real mouse → snap vx/vy, hide the overlay (native cursor is visible)
window.addEventListener('mousemove', e => {
  vx = e.clientX;
  vy = e.clientY;
  if (cursorVisible) {
    cursorVisible = false;
    cursorEl.style.display = 'none';
  }
});

// WASM mouse_move → move overlay
window.addEventListener('clx:mouse_move', e => {
  const [dx, dy] = e.detail;
  setCursorPos(vx + dx, vy + dy);
  cursorVisible = true;
  cursorEl.style.display = 'block';
});

// Expose position for e2e tests
window.__clxGetCursorPos = () => ({ x: vx, y: vy, visible: cursorVisible });

// ── Scroll at virtual cursor ──────────────────────────────────────────────────

// elementsFromPoint returns all elements overlapping (x, y) from topmost to
// bottommost, including ancestor elements.  We scan for the first one that is
// actually scrollable in the given axis.
function findScrollableAtPoint(x, y, vertical) {
  const hits = document.elementsFromPoint(x, y);
  for (const el of hits) {
    if (el === document.documentElement) continue;
    const st = getComputedStyle(el);
    const ov = vertical ? st.overflowY : st.overflowX;
    if (ov !== 'auto' && ov !== 'scroll') continue;
    const scrollable = vertical
      ? el.scrollHeight > el.clientHeight
      : el.scrollWidth  > el.clientWidth;
    if (scrollable) return el;
  }
  return null;
}

window.addEventListener('clx:scroll_v', e => {
  const pixels = e.detail;  // negative = scroll up, positive = scroll down
  const target = findScrollableAtPoint(vx, vy, true);
  if (target) target.scrollBy({ top: pixels, behavior: 'instant' });
  else        window.scrollBy({ top: pixels, behavior: 'instant' });
});

window.addEventListener('clx:scroll_h', e => {
  const pixels = e.detail;
  const target = findScrollableAtPoint(vx, vy, false);
  if (target) target.scrollBy({ left: pixels, behavior: 'instant' });
  else        window.scrollBy({ left: pixels, behavior: 'instant' });
});

// ── Cursor movement for textarea / input (clx:cursor_move) ───────────────────
// Chrome does NOT move selectionStart for untrusted synthetic KeyboardEvents.
// WASM dispatches clx:cursor_move with the direction string so we can
// manipulate selectionStart directly.

window.addEventListener('clx:cursor_move', e => {
  const el = document.activeElement;
  if (!el) return;
  const tag = el.tagName;
  if (tag !== 'TEXTAREA' && tag !== 'INPUT') return;
  const val = el.value ?? '';
  let pos = el.selectionStart ?? 0;
  switch (e.detail) {
    case 'ArrowLeft':  pos = Math.max(0, pos - 1); break;
    case 'ArrowRight': pos = Math.min(val.length, pos + 1); break;
    case 'Home': {
      const nl = val.lastIndexOf('\n', pos - 1);
      pos = nl === -1 ? 0 : nl + 1;
      break;
    }
    case 'End': {
      const nl = val.indexOf('\n', pos);
      pos = nl === -1 ? val.length : nl;
      break;
    }
    case 'ArrowUp': {
      const before  = val.slice(0, pos);
      const curNl   = before.lastIndexOf('\n');   // \n ending prev line, or -1
      const col     = pos - (curNl + 1);          // 0-based column
      if (curNl <= 0) { pos = 0; break; }         // already on first line
      const prevNl  = val.lastIndexOf('\n', curNl - 1);
      pos = prevNl + 1 + Math.min(col, curNl - prevNl - 1);
      break;
    }
    case 'ArrowDown': {
      const before      = val.slice(0, pos);
      const curNl       = before.lastIndexOf('\n');
      const col         = pos - (curNl + 1);
      const nextNl      = val.indexOf('\n', pos);
      if (nextNl === -1) { pos = val.length; break; }  // already on last line
      const afterNextNl = val.indexOf('\n', nextNl + 1);
      const nextLineLen = (afterNextNl === -1 ? val.length : afterNextNl) - nextNl - 1;
      pos = nextNl + 1 + Math.min(col, nextLineLen);
      break;
    }
    case 'PageUp':   pos = 0; break;
    case 'PageDown': pos = val.length; break;
  }
  el.setSelectionRange(pos, pos);
});

// ── Focus cycling (N / P = Tab / Shift+Tab) ───────────────────────────────────

const TABBABLE = [
  'a[href]',
  'button:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
].join(', ');

window.addEventListener('clx:focus', e => {
  const dir = e.detail; // 1 = forward, -1 = backward
  const all = Array.from(document.querySelectorAll(TABBABLE));
  if (all.length === 0) return;
  const cur  = all.indexOf(document.activeElement);
  const next = all[(cur + dir + all.length) % all.length];
  next?.focus();
});

// ── CLX status tracking ───────────────────────────────────────────────────────
// Register BEFORE start() so our listener fires first in capture phase.
const statusEl = document.getElementById('status');
let capsHeld = false, spaceHeld = false, locked = false;

function refreshStatus() {
  if (locked) {
    statusEl.className = 'locked';
    statusEl.textContent = 'CLX LOCKED';
  } else if (capsHeld || spaceHeld) {
    statusEl.className = 'fn';
    statusEl.textContent = 'CLX HELD';
  } else {
    statusEl.className = 'off';
    statusEl.textContent = 'CLX OFF';
    // Virtual cursor stays visible until real mouse moves – do NOT hide here.
  }
}

window.addEventListener('keydown', e => {
  if (!e.isTrusted) return;
  if (e.code === 'CapsLock') capsHeld  = true;
  if (e.code === 'Space')    spaceHeld = true;
  if (capsHeld && spaceHeld) locked = true;
  refreshStatus();
}, { capture: true });

window.addEventListener('keyup', e => {
  if (!e.isTrusted) return;
  if (e.code === 'CapsLock') { capsHeld = false; if (locked && !spaceHeld) locked = false; }
  if (e.code === 'Space')    { spaceHeld = false; if (locked && !capsHeld) locked = false; }
  refreshStatus();
}, { capture: true });

// ── Key log (bubble phase = only events CLX let through) ─────────────────────
const logBox = document.getElementById('log-box');
const t0 = Date.now();

function logEvent(e) {
  if (!e.isTrusted) return;
  const ts  = ((Date.now() - t0) / 1000).toFixed(2).padStart(5);
  const dir = e.type === 'keydown' ? 'dn' : 'up';
  const row = document.createElement('div');
  row.className = `le le-${dir}`;
  row.innerHTML =
    `<span class="le-t">${ts}s</span>` +
    `<span class="le-${dir}">${dir}</span>` +
    `<span class="le-code">${e.code}</span>` +
    `<span class="le-key">${e.key.length === 1 ? JSON.stringify(e.key) : ''}</span>`;
  logBox.appendChild(row);
  logBox.scrollTop = logBox.scrollHeight;
  while (logBox.children.length > 200) logBox.firstChild.remove();
}
window.addEventListener('keydown', logEvent);
window.addEventListener('keyup',   logEvent);

document.getElementById('clear-log').onclick = () => { logBox.innerHTML = ''; };

// ── Scroll test filler ────────────────────────────────────────────────────────
const box = document.getElementById('scroll-box');
for (let i = 1; i <= 50; i++) {
  const d = document.createElement('div');
  d.textContent = `Line ${i.toString().padStart(2)} – CLX+R (up) or F (down) while cursor is here`;
  box.appendChild(d);
}

// ── Load WASM ─────────────────────────────────────────────────────────────────
const badge = document.getElementById('wasm-badge');
try {
  const mod = await import('../pkg/capslockx_browser.js');
  await mod.default();   // init()
  mod.start();
  badge.textContent = 'WASM ✓';
  badge.className   = 'ok';
} catch (err) {
  console.error('[CLX test]', err);
  badge.textContent = 'WASM ✗';
  document.getElementById('err').style.display = 'block';
}
</script>
</body>
</html>
